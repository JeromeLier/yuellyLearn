可重入锁和 非可重入锁
 如果一个线程递归访问当前方法， 如果能够访问的话，就是可重入锁，  如果不能就是非可重入锁
  synchronized 和 lock 都是可重入锁， 非重入锁可以自己手写实现  http://blog.csdn.net/soonfly/article/details/70918802

### 自定义实现可重入锁和不可重入锁



### synchronized 锁
事实上，synchronized修饰非静态方法、同步代码块的synchronized (this)用法和synchronized (非this对象)的用法锁的是对象，线程想要执行对应同步代码，需要获得对象锁。

synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。



对于同一个类A，线程1争夺A对象实例的对象锁，线程2争夺类A的类锁，这两者不存在竞争关系。也就说对象锁和类锁互补干预内政

静态方法则一定会同步，非静态方法需在单例模式才生效，但是也不能都用静态同步方法，总之用得不好可能会给性能带来极大的影响。另外，有必要说一下的是Spring的bean默认是单例的。
